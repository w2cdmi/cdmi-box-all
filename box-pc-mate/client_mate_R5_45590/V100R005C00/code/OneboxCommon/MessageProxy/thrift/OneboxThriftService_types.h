/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef OneboxThriftService_TYPES_H
#define OneboxThriftService_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace OneboxThriftService {

struct Service_Status {
  enum type {
    Service_Status_Online = 0,
    Service_Status_Offline = 1,
    Service_Status_Error = 2,
    Service_Status_Pause = 3,
    Service_Status_Uninitial = 4
  };
};

extern const std::map<int, const char*> _Service_Status_VALUES_TO_NAMES;

typedef struct _File_Node__isset {
  _File_Node__isset() : id(false), parent(false), name(false), type(false), size(false), mtime(false), ctime(false), flags(false), extraType(false) {}
  bool id;
  bool parent;
  bool name;
  bool type;
  bool size;
  bool mtime;
  bool ctime;
  bool flags;
  bool extraType;
} _File_Node__isset;

class File_Node {
 public:

  static const char* ascii_fingerprint; // = "B1450930277FAE79F3E997B1270AA97B";
  static const uint8_t binary_fingerprint[16]; // = {0xB1,0x45,0x09,0x30,0x27,0x7F,0xAE,0x79,0xF3,0xE9,0x97,0xB1,0x27,0x0A,0xA9,0x7B};

  File_Node() : id(0), parent(0), name(), type(0), size(0), mtime(0), ctime(0), flags(0), extraType(0) {
  }

  virtual ~File_Node() throw() {}

  int64_t id;
  int64_t parent;
  std::string name;
  int32_t type;
  int64_t size;
  int64_t mtime;
  int64_t ctime;
  int32_t flags;
  int32_t extraType;

  _File_Node__isset __isset;

  void __set_id(const int64_t val) {
    id = val;
  }

  void __set_parent(const int64_t val) {
    parent = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_type(const int32_t val) {
    type = val;
  }

  void __set_size(const int64_t val) {
    size = val;
  }

  void __set_mtime(const int64_t val) {
    mtime = val;
  }

  void __set_ctime(const int64_t val) {
    ctime = val;
  }

  void __set_flags(const int32_t val) {
    flags = val;
  }

  void __set_extraType(const int32_t val) {
    extraType = val;
  }

  bool operator == (const File_Node & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(parent == rhs.parent))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(size == rhs.size))
      return false;
    if (!(mtime == rhs.mtime))
      return false;
    if (!(ctime == rhs.ctime))
      return false;
    if (!(flags == rhs.flags))
      return false;
    if (!(extraType == rhs.extraType))
      return false;
    return true;
  }
  bool operator != (const File_Node &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const File_Node & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(File_Node &a, File_Node &b);

typedef struct _TransTask_RootNode__isset {
  _TransTask_RootNode__isset() : group(false), source(false), parent(false), name(false), type(false), fileType(false), status(false), statusEx(false), userId(false), userType(false), userName(false), priority(false), size(false), transedSize(false), errorCode(false) {}
  bool group;
  bool source;
  bool parent;
  bool name;
  bool type;
  bool fileType;
  bool status;
  bool statusEx;
  bool userId;
  bool userType;
  bool userName;
  bool priority;
  bool size;
  bool transedSize;
  bool errorCode;
} _TransTask_RootNode__isset;

class TransTask_RootNode {
 public:

  static const char* ascii_fingerprint; // = "2290BAE3EAAB6B9FB3F8D1C7039A5324";
  static const uint8_t binary_fingerprint[16]; // = {0x22,0x90,0xBA,0xE3,0xEA,0xAB,0x6B,0x9F,0xB3,0xF8,0xD1,0xC7,0x03,0x9A,0x53,0x24};

  TransTask_RootNode() : group(), source(), parent(), name(), type(0), fileType(0), status(0), statusEx(0), userId(0), userType(0), userName(), priority(0), size(0), transedSize(0), errorCode(0) {
  }

  virtual ~TransTask_RootNode() throw() {}

  std::string group;
  std::string source;
  std::string parent;
  std::string name;
  int32_t type;
  int32_t fileType;
  int32_t status;
  int32_t statusEx;
  int64_t userId;
  int32_t userType;
  std::string userName;
  int32_t priority;
  int64_t size;
  int64_t transedSize;
  int32_t errorCode;

  _TransTask_RootNode__isset __isset;

  void __set_group(const std::string& val) {
    group = val;
  }

  void __set_source(const std::string& val) {
    source = val;
  }

  void __set_parent(const std::string& val) {
    parent = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_type(const int32_t val) {
    type = val;
  }

  void __set_fileType(const int32_t val) {
    fileType = val;
  }

  void __set_status(const int32_t val) {
    status = val;
  }

  void __set_statusEx(const int32_t val) {
    statusEx = val;
  }

  void __set_userId(const int64_t val) {
    userId = val;
  }

  void __set_userType(const int32_t val) {
    userType = val;
  }

  void __set_userName(const std::string& val) {
    userName = val;
  }

  void __set_priority(const int32_t val) {
    priority = val;
  }

  void __set_size(const int64_t val) {
    size = val;
  }

  void __set_transedSize(const int64_t val) {
    transedSize = val;
  }

  void __set_errorCode(const int32_t val) {
    errorCode = val;
  }

  bool operator == (const TransTask_RootNode & rhs) const
  {
    if (!(group == rhs.group))
      return false;
    if (!(source == rhs.source))
      return false;
    if (!(parent == rhs.parent))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(fileType == rhs.fileType))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(statusEx == rhs.statusEx))
      return false;
    if (!(userId == rhs.userId))
      return false;
    if (!(userType == rhs.userType))
      return false;
    if (!(userName == rhs.userName))
      return false;
    if (!(priority == rhs.priority))
      return false;
    if (!(size == rhs.size))
      return false;
    if (!(transedSize == rhs.transedSize))
      return false;
    if (!(errorCode == rhs.errorCode))
      return false;
    return true;
  }
  bool operator != (const TransTask_RootNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TransTask_RootNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TransTask_RootNode &a, TransTask_RootNode &b);

typedef struct _TeamSpace_Node__isset {
  _TeamSpace_Node__isset() : id(false), name(false) {}
  bool id;
  bool name;
} _TeamSpace_Node__isset;

class TeamSpace_Node {
 public:

  static const char* ascii_fingerprint; // = "727CAEA8265A5DE67DBC931F55CD8753";
  static const uint8_t binary_fingerprint[16]; // = {0x72,0x7C,0xAE,0xA8,0x26,0x5A,0x5D,0xE6,0x7D,0xBC,0x93,0x1F,0x55,0xCD,0x87,0x53};

  TeamSpace_Node() : id(0), name() {
  }

  virtual ~TeamSpace_Node() throw() {}

  int64_t id;
  std::string name;

  _TeamSpace_Node__isset __isset;

  void __set_id(const int64_t val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  bool operator == (const TeamSpace_Node & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const TeamSpace_Node &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TeamSpace_Node & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TeamSpace_Node &a, TeamSpace_Node &b);

} // namespace

#endif
